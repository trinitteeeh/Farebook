package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"time"

	"github.com/Trinitt/learn-graphql/graph/model"
	"github.com/google/uuid"
)

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, name string, description string, profileURL string, privacy string) (*model.Group, error) {
	group := &model.Group{
		ID:          uuid.NewString(),
		Name:        name,
		Description: description,
		CreatedAt:   time.Now().Format("2006-01-02 15:04:05"),
		ProfileURL:  profileURL,
		Privacy:     privacy,
	}
	return group, r.DB.Create(&group).Error
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, id string) (*model.Group, error) {
	err := r.DB.Where("id = ?", id).Delete(&model.Group{}).Error

	if err != nil {
		return nil, err
	}
	return &model.Group{}, err
}

// GetGroupsByUserID is the resolver for the getGroupsByUserID field.
func (r *queryResolver) GetGroupsByUserID(ctx context.Context, userID string) ([]*model.FetchGroup, error) {
	var groups []*model.Group

	err := r.DB.Raw(`SELECT * FROM groups JOIN group_members ON groups.id = group_members.group_id WHERE group_members.member_id = ?`, userID).Scan(&groups).Error
	if err != nil {
		return nil, err
	}

	var fetchGroups []*model.FetchGroup

	for _, group := range groups {
		fetchGroup, err := r.GetGroupByID(ctx, group.ID, userID)
		if err != nil {
			return nil, err
		}
		fetchGroups = append(fetchGroups, fetchGroup)
	}

	return fetchGroups, nil
}

// GetGroupByID is the resolver for the getGroupByID field.
func (r *queryResolver) GetGroupByID(ctx context.Context, id string, userID string) (*model.FetchGroup, error) {
	group := &model.Group{}
	err := r.DB.First(&group, "id = ?", id).Error
	if err != nil {
		return nil, err
	}

	fetchGroup := &model.FetchGroup{
		ID:          group.ID,
		Name:        group.Name,
		Description: group.Description,
		CreatedAt:   group.CreatedAt,
		ProfileURL:  group.ProfileURL,
		Privacy:     group.Privacy,
	}

	var members []*model.FetchGroupMember
	var users []*model.User

	err = r.DB.Raw(`
		SELECT *
		FROM users 
		JOIN group_members ON users.id = group_members.member_id 
		WHERE group_members.group_id = ?`, id).Scan(&users).Error
	if err != nil {
		return nil, err
	}

	for _, user := range users {
		var role string
		err := r.DB.Raw(`SELECT role FROM group_members where member_id = ?`, user.ID).Scan(&role).Error
		if err != nil {
			return nil, err
		}

		var status string
		err = r.DB.Raw(`SELECT status FROM group_members where member_id = ?`, user.ID).Scan(&status).Error
		if err != nil {
			return nil, err
		}

		member := &model.FetchGroupMember{
			User:   user,
			Role:   role,
			Status: status,
		}
		members = append(members, member)
	}
	fetchGroup.Members = members

	//FETCH POSTS
	var posts []*model.Post
	var fetchPosts []*model.FetchPost

	err = r.DB.Raw(`
    SELECT p.* 
    FROM posts p
    JOIN group_posts gp ON p.id = gp.post_id
    WHERE gp.group_id = ?`, id).Scan(&posts).Error
	if err != nil {
		return nil, err
	}

	for _, post := range posts {
		fetchPost := &model.FetchPost{
			ID:          post.ID,
			PostText:    post.PostText,
			PublishDate: post.PublishDate,
			Privacy:     post.Privacy,
			User:        nil,
			LikesCount:  0,
			MediaLink:   nil,
			IsLiked:     false,
		}
		// Retrieve User Data
		var user model.User
		if err := r.DB.Where("id = ?", post.UserID).First(&user).Error; err != nil {
			return nil, err
		}
		fetchPost.User = &user

		//Retrieve Media Data
		var mediaLink []string
		var mediaList []*model.PostPicture
		if err := r.DB.Where("post_id = ?", post.ID).Find(&mediaList).Error; err != nil {
			return nil, err
		}
		for _, media := range mediaList {
			mediaLink = append(mediaLink, media.PictureURL)
		}
		fetchPost.MediaLink = mediaLink

		// Count likes for the current post
		var likeCount int64
		if err := r.DB.Model(&model.PostLike{}).Where("post_id = ?", post.ID).Count(&likeCount).Error; err != nil {
			return nil, err
		}
		fetchPost.LikesCount = int(likeCount)

		//retrieve is liked
		var isLikedCount int64
		if err := r.DB.Model(&model.PostLike{}).
			Where("post_id = ? AND user_id = ?", post.ID, userID).
			Count(&isLikedCount).Error; err != nil {
			return nil, err
		}
		fetchPost.IsLiked = isLikedCount > 0

		fetchPosts = append(fetchPosts, fetchPost)
	}

	fetchGroup.Posts = fetchPosts

	return fetchGroup, nil
}

// GetAllGroup is the resolver for the getAllGroup field.
func (r *queryResolver) GetAllGroup(ctx context.Context, userID string) ([]*model.FetchGroup, error) {
	var groups []*model.Group
	err := r.DB.Find(&groups).Error
	if err != nil {
		return nil, err
	}

	var fetchGroups []*model.FetchGroup

	for _, group := range groups {
		fetchGroup, err := r.GetGroupByID(ctx, group.ID, userID)
		if err != nil {
			return nil, err
		}
		fetchGroups = append(fetchGroups, fetchGroup)
	}

	return fetchGroups, nil
}

// GetGroupRecommendation is the resolver for the getGroupRecommendation field.
func (r *queryResolver) GetGroupRecommendation(ctx context.Context, userID string) ([]*model.FetchGroup, error) {
	var groups []*model.Group

	err := r.DB.Raw(`
		SELECT * FROM groups 
		WHERE id NOT IN (
			SELECT group_id FROM group_members WHERE member_id = ?
		)
	`, userID).Scan(&groups).Error

	if err != nil {
		return nil, err
	}

	var fetchGroups []*model.FetchGroup

	for _, group := range groups {
		fetchGroup, err := r.GetGroupByID(ctx, group.ID, userID)
		if err != nil {
			return nil, err
		}
		fetchGroups = append(fetchGroups, fetchGroup)
	}

	return fetchGroups, nil
}
