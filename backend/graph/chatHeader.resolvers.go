package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"time"

	"github.com/Trinitt/learn-graphql/graph/model"
	"github.com/google/uuid"
)

// CreateChatHeader is the resolver for the createChatHeader field.
func (r *mutationResolver) CreateChatHeader(ctx context.Context, newChatHeader model.NewChatHeader) (*model.ChatHeader, error) {
	currentTime := time.Now()
	createdAt := currentTime.Format("2006-01-02 15:04:05")

	chatHeader := &model.ChatHeader{
		ID:        uuid.NewString(),
		UserID1:   newChatHeader.UserID1,
		UserID2:   newChatHeader.UserID2,
		CreatedAt: createdAt,
	}
	return chatHeader, r.DB.Save(&chatHeader).Error
}

// GetAllChatHeaders is the resolver for the getAllChatHeaders field.
func (r *queryResolver) GetAllChatHeaders(ctx context.Context, userID *string) ([]*model.FetchChatHeader, error) {
	var chatHeaders []*model.ChatHeader

	// Fetch chat headers where UserID1 or UserID2 matches userID
	if err := r.DB.Where("user_id1 = ? OR user_id2 = ?", *userID, *userID).Find(&chatHeaders).Error; err != nil {
		return nil, err
	}

	var fetchChatHeaders []*model.FetchChatHeader

	// Fetch user information for each FetchChatHeader
	for _, chatHeader := range chatHeaders {
		fetchChatHeader := &model.FetchChatHeader{
			ID:        chatHeader.ID,
			User1:     nil,
			User2:     nil,
			CreatedAt: chatHeader.CreatedAt,
		}

		var user1 model.User
		if err := r.DB.First(&user1, "id = ?", chatHeader.UserID1).Error; err != nil {
			return nil, err
		}
		fetchChatHeader.User1 = &user1

		var user2 model.User
		if err := r.DB.First(&user2, "id = ?", chatHeader.UserID2).Error; err != nil {
			return nil, err
		}
		fetchChatHeader.User2 = &user2

		fetchChatHeaders = append(fetchChatHeaders, fetchChatHeader)
	}

	return fetchChatHeaders, nil
}
