package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"

	"github.com/Trinitt/learn-graphql/graph/model"
	"github.com/google/uuid"
)

// CreatePostComment is the resolver for the createPostComment field.
func (r *mutationResolver) CreatePostComment(ctx context.Context, postID string, userID string, commentText string) (*model.PostComment, error) {
	postComment := &model.PostComment{
		ID:          uuid.NewString(),
		PostID:      postID,
		UserID:      userID,
		CommentText: commentText,
	}
	return postComment, r.DB.Create(&postComment).Error
}

// DeletePostComment is the resolver for the deletePostComment field.
func (r *mutationResolver) DeletePostComment(ctx context.Context, id string) (*model.PostComment, error) {
	err := r.DB.Where("id = ?", id).Delete(&model.PostComment{}).Error

	if err != nil {
		return nil, err
	}
	return &model.PostComment{}, err
}

// GetPostComments is the resolver for the getPostComments field.
func (r *queryResolver) GetPostComments(ctx context.Context, postID string) ([]*model.FetchPostComments, error) {
	var comments []*model.PostComment

	if err := r.DB.Where("post_id = ?", postID).Find(&comments).Error; err != nil {
		return nil, err
	}

	var fetchPostComments []*model.FetchPostComments

	for _, comment := range comments {
		postComment := &model.FetchPostComments{
			ID:          comment.ID,
			PostID:      comment.PostID,
			CommentText: comment.CommentText,
			User:        nil,
			Replies:     nil,
		}

		//fetch user
		user := &model.User{}
		err := r.DB.First(&user, "id = ?", comment.UserID).Error
		if err != nil {
			return nil, err
		}
		postComment.User = user

		//fetch replies
		var replies []*model.PostCommentReply
		var commentReplies []*model.FetchPostCommentReplies

		if err := r.DB.Where("parent_id = ?", comment.ID).Find(&replies).Error; err != nil {
			return nil, err
		}

		for _, reply := range replies {
			commentReply := &model.FetchPostCommentReplies{
				ID:          reply.ID,
				PostID:      reply.PostID,
				CommentText: reply.CommentText,
				User:        nil,
				Parent:      comment,
			}

			userReply := &model.User{}
			err := r.DB.First(&userReply, "id = ?", reply.UserID).Error
			if err != nil {
				return nil, err
			}
			commentReply.User = userReply
			commentReplies = append(commentReplies, commentReply)
		}
		postComment.Replies = commentReplies
		fetchPostComments = append(fetchPostComments, postComment)
	}

	return fetchPostComments, nil
}
