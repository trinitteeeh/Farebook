package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"

	"github.com/Trinitt/learn-graphql/graph/model"
)

// CreateFriendship is the resolver for the createFriendship field.
func (r *mutationResolver) CreateFriendship(ctx context.Context, userID string, friendID string) (*model.Friendship, error) {
	friendship := &model.Friendship{
		UserID:   userID,
		FriendID: friendID,
		Status:   "Pending",
	}
	return friendship, r.DB.Create(&friendship).Error
}

// DeleteFriendship is the resolver for the deleteFriendship field.
func (r *mutationResolver) DeleteFriendship(ctx context.Context, userID string, friendID string) (*model.Friendship, error) {
	err := r.DB.Where("user_id = ? AND friend_id = ? OR user_id = ? AND friend_id = ?", userID, friendID, friendID, userID).Delete(&model.Friendship{}).Error

	if err != nil {
		return nil, err
	}
	return &model.Friendship{}, err
}

// ConfirmFriendship is the resolver for the confirmFriendship field.
func (r *mutationResolver) ConfirmFriendship(ctx context.Context, userID string, friendID string) (*model.Friendship, error) {
	if err := r.DB.Exec(`
    UPDATE friendships
    SET status = 'Valid'
    WHERE (user_id = ? AND friend_id = ?) OR (user_id = ? AND friend_id = ?)
`, userID, friendID, friendID, userID).Error; err != nil {
		return nil, err
	}
	return &model.Friendship{}, nil
}

// GetAllFriends is the resolver for the getAllFriends field.
func (r *queryResolver) GetAllFriends(ctx context.Context, userID string) ([]*model.User, error) {
	var friends []*model.User

	if err := r.DB.Raw(`
        SELECT u.*
        FROM friendships f
        INNER JOIN users u ON (f.friend_id = u.id AND f.user_id = ?) OR (f.user_id = u.id AND f.friend_id = ?)
        WHERE (f.user_id = ? AND f.status = 'Valid') OR (f.friend_id = ? AND f.status = 'Valid')
    `, userID, userID, userID, userID).Scan(&friends).Error; err != nil {
		return nil, err
	}

	return friends, nil
}

// GetAllFriendRequests is the resolver for the getAllFriendRequests field.
func (r *queryResolver) GetAllFriendRequests(ctx context.Context, userID string) ([]*model.User, error) {
	var requests []*model.User

	if err := r.DB.Raw(`
        SELECT u.*
        FROM friendships f
        INNER JOIN users u ON f.user_id = u.id
        WHERE f.friend_id = ? AND status != 'Valid'
    `, userID).Scan(&requests).Error; err != nil {
		return nil, err
	}

	return requests, nil
}

// GetAllFriendSuggestions is the resolver for the getAllFriendSuggestions field.
func (r *queryResolver) GetAllFriendSuggestions(ctx context.Context, userID string) ([]*model.User, error) {
	friendsOfA, err := r.GetAllFriends(ctx, userID)
	if err != nil {
		return nil, err
	}

	// Create a map to store user IDs of friends and friends of friends
	friendIDs := make(map[string]bool)
	for _, friend := range friendsOfA {
		friendIDs[friend.ID] = true

		friendsOfFriend, err := r.GetAllFriends(ctx, friend.ID)
		if err != nil {
			return nil, err
		}

		for _, fof := range friendsOfFriend {
			friendIDs[fof.ID] = true
		}
	}

	// Extract user IDs from friendsOfA
	friendIDsOfA := make(map[string]bool)
	for _, friend := range friendsOfA {
		friendIDsOfA[friend.ID] = true
	}

	// Fetch user details for friend recommendations
	var recommendations []*model.User
	if err := r.DB.
		Table("users").
		Where("id IN ?", keys(friendIDs)).
		Not("id = ?", userID).
		Not("id IN ?", keys(friendIDsOfA)).
		Find(&recommendations).Error; err != nil {
		return nil, err
	}

	return recommendations, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func keys(m map[string]bool) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}
